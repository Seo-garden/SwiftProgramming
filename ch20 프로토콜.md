# 프로토콜
### chapter20.1 Protocol
프로토콜이란 ? 특정 역할을 하기 위한 메서드, 프로퍼티, 기타 요구사항 등의 청사진을 정의함. 구조체, 클래스, 열거형은 프로토콜을 채택해서 특정 기능을 실행하기 위한 프로토콜의 요구사항을 실제로 구현할 수 있습니다. 어떤 프로토콜을의 요구사항을 모두 따르는 타입은 '해당 프로토콜을 준수한다'라고 표현한다. 
    
    즉, 프로토콜은 정의를 하고 제시만 할 뿐이지 스스로 기능을 구현하지는 않는다.
---------------------------------------
### chapter20.2 프로토콜 채택
프로토콜은 구조체, 클래스, 열거형처럼 정의할 수 있으며, protocol 키워드를 쓴다.

    class SomeClass: SuperClass, AProtocol, AnotherProtocol {
        //클래스를 정의 SomeClass 는 SuperClass 를 상속받았고, 동시에 Aprotocol, AnotherProtocol 프로토콜을 채택함.
    }
---------------------------------------

### chapter20.3.1 프로토콜 요구
프로토콜은 자신을 채택한 타입이 어떤 프로퍼티를 구현해야 하는지 요구할 수 있음. 프로토콜을 채택한 타입은 프로토콜이 요구하는 프로퍼티의 이름과 타입만 맞도록 구현해주면 됨. 프로토콜의 프로퍼티 요구사항은 항상 var 키워드를 사용한 변수 프로퍼티로 정의한다. 

타입 프로퍼티를 요구하려면 static 키워드를 사용해야한다. 클래스의 타입 프로퍼티에는 상속 가능한 타입 프로퍼티인 class 타입 프로퍼티와 상속 불가능한 static 타입 프로퍼티가 있지만 이 두 타입 프로퍼티를 따로 구분하지 않고 모두 static 키워드를 사용하여 타입 프로퍼티를 요구하면 된다.

코드 20-4 기반으로 Sendable 프로토콜에서 요구한 프로퍼티는 읽기 가능한 프로퍼티였지만 실제로 프로토콜이 채택한 클래스에서 구현할 때는 읽고 쓰기가 가능한 프로퍼티로 구현해도 전혀 문제가 없다.

-------------------------------
### chapter 20.3.2 메서드 요구
프로토콜이 요구할 메서드는 프로토콜 정의에서 작성한다. 다만 메서드의 실제 구현부인 중괄호 {} 부분은 제외하고 메서드의 이름, 매개변수, 반환 타입 등만 작성하며 가변 매개변수도 허용한다. 프로토콜의 메서드 요구에서는 매개변수 기본값을 지정할 수 없습니다. 
코드 20-5의 Mail, Message 클래스의 isSendableInstance(_ :) 메서드는 각각 class와 static 타입 메서드로 구현했다. 프로토콜에서 static 키워드를 통해 타입 메서드를 요구했지만 클래스에서 실제로 구현할 때 class 타입 메서드로 구현할지, static 타입 메서드로 구현할 지는 프로토콜이 채택하여 사용하는 클래스의 특성에 따라 골라 사용하면 된다.
--------------------------------
### chapter 20.3.3 가변 메서드 요구
가끔은 메서드가 인스턴스 내부의 값을 변경할 필요가 있다. 값 타입(구조체, 열거형 )의 인스턴스 메서드에서 자신 내부의 값을 변경하고자 할 떄는 메서드의 func 키워드 앞에 mutating 키워드를 적어 메서드에서 인스턴스 내부의 값을 변경한다는 것을 알려준다.

프로토콜에 mutating 키워드를 사용한 메서드 요구가 있다 하더라도 클래스 구현에서는 mutating 키워드를 써주지 않아도 된다.
--------------------------------
### chapter 20.3.4 이니셜라이저 요구
프로토콜에서 이니셜라이저를 요구하려면 메서드 요구와 마찬가지로 이니셜라이저를 정의하지만 구현은 하지 않는다.
클래스 타입에서 이니셜라이저 요구에 부합하는 이니셜라이저를 구현할 때는 required 식별자를 붙인 이니셜라이저로 구현해야 한다. 만약 final 클래스의 경우 required 식별자를 붙여줄 필요는 없다. 상속할 수 없는 클래스의 요청 이니셜라이저 구현은 의미가 없기 때문이다. //code20-8

만약 특정 클래스에 프로토콜이 요구하는 이니셜라이저가 이미 구현되어 있는 사오항에서 그 클래스를 상속받은 클래스가 있다면, required 와 override 식별자를 모두 명시하여 프로토콜에서 요구하는 이니셜라이저를 구현해야 한다.
------------------------------------------
### chapter 20.4 프로토콜의 상속과 클래스 전용 프로토콜
프로토콜은 하나 이상의 프로토콜을 상속받아 기존 프로토코르이 요구사항보다 더 많은 요구사항을 추가할 수 있다. 프로토콜의 상속 리스트에 class 키워드를 추가해 프로토콜이 클래스 타입에만 채택할 수 있도록 제한할 수 있다. 클래스 전용 프로토콜로 제한을 주기 위해서는 프로토콜의 상속 리스트의 맨 처음에 class 키워드를 위치해야 한다.

    protocol ClassOnlyProtocol : class, SuperProtocol, SubProtocol {
        //추가 요구 사항
    }
    
------------------------------------------
### chapter 20.5 프로토콜 조합과 프로토콜 준수 확인
하나의 매개변수가 여러 프로토콜을 모두 준수하는 타입이어야 한다면 하나의 매개변수에 여러 프로토콜을 한 번에 조합하여 요구할 수 있다. & 를 여러 프로토콜 사이에 넣으면 된다. 구조체나 열거형은 조합할 수 없다.
타입캐스팅에 사용하던 is 와 as 연산자를 통해 대상 프로토콜을 준수하는지 확인할 수도 있고, 특정 프로토콜로 캐스팅할 수 있다. 

    is 연산자를 통해 해당 인스턴스가 특정 프로토콜을 준수하는지 확인할 수 있다.
    as? 다운캐스팅 연산자를 통해 다른 프로토콜로 다운캐스팅을 시도해볼 수 있다.
    as! 다운캐스팅 연산자를 통해 다른 프로토콜로 강제 다운캐스팅을 할 수 있다.

------------------------------------------
### chapter 20.6 프로토콜의 선택적 요구
선택적 요구를 하면 프로토콜을 준수하는 타입에 해당 요구사항을 필수로 구현할 필요가 없다. optional 식별자를 요구사항의 정의 앞에 붙여주면 된다. 예를 들어 (Int) -> String 타입의 메서드는 (Int) -> String? 타입이 되어 메서드의 매개변수나 바노한 타입이 옵셔널이 된 것이 아니라 메서드(함수) 자체의 타입이 옵셔널이 된 것이라는 것이다.
-------------------------------------------
### chapter 20.8 위임을 위한 프로토콜
위임(Delegation) 은 클래스나 구조체가 자신의 책임이나 임무를 다른 타입의 인스턴스에게 위임하는 디자인패턴이다. 책무를 위임하기 위해 정의한 프로토콜을 준수하는 타입은 자신이 해야 할 일을 미독 맡길 수 있다. 위임은 사용자의 특정 행동에 반응하기 위해 사용되기도 하고, 비동기 처리에도 많이 사용한다.

위임패턴 은 애플의 프레임워크에서 사용하는 주요한 패턴 중 하나이다. 언어 자체로의 기능이 아닌 하나의 디자인 패턴이지만 애플의 프레임워크에서 중요하게 사용되는 만큼, 개념을 알아두면 앞으로 애플 플랫폼의 애플리케이션을 만들 때 도움이 된다.
