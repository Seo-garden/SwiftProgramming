# 제네릭(Generics)
### chapter 22.1 제네릭
스위프트의 강력한 기능중 하나이다. 제네릭을 이용해 코드를 구현하면 어떤 타입에도 유연하게 대응할 수 있다. 구현한 기능과 타입은 재사용이 쉽고, 코드의 중복을 줄일 수 있기에 깔끔하고 추상적인 표현이 가능하다. Swift 에서는 타입 안정성 언어이고 String 타입의 변수와 Double 타입의 변수가 서로 값을 바꾸도록 허락하지 않는다. 이러한 시도는 컴파일 에러가 발생한다.

제네릭 함수는 실제 타입 이름 (Int, String) 을 써주는 대신에 플레이스홀더 <T> 를 쓴다. 플레이스홀더는 타입의 종류를 알려주진 않지만 말 그대로 어떤 타입이라는 것을 알려준다. 즉 매개변수로 플레이스홀더 타입이 T 인 두 매개변수가 있으므로, 두 매개변수는 같은 타입이라는 정도는 알 수 있다. <T> 가 플레이스홀더로 사용되기 때문에 스위프트 컴파일러는 함수의 문법을 검사할 때, T의 실제 타입을 신경쓰지 않는다.
---------------------------------------------------------------- 
### chapter 22.2 제네릭 타입
제네릭 함수에 이어 제네릭 타입을 구현할 수 있습니다. 제네릭 타입을 구현하면 사용자 정의의 타입인 구조체, 클래스, 열거형 등이 어떤 타입과도 연관되어 동작할 수 있다. 
코드[22-8] 의 아래쪽에 사용한 anyStack 의 예처럼 Element 타입으로 Any 를 사용해도 무방하다. Stack 의 items 배열을 Any 타입으로 정의하는 것보다 제네릭을 사용했을 때 훨씬 유연하고 광범위하게 사용할 수 있으며, Element 의 타입을 정해주면 그 타입에만 동작하도록 제한할 수 있어 더욱 안전하고 의도한 대로 기능을 사용하도록 유도할 수 있다.
-----------------------------------------------------------------
### chapter 22.3 제네릭 타입 확장
만약 익스텐션을 통해 제네릭을 사용하는 타입에 기능을 추가하고자 한다면 익스텐션 정의에 타입 매개변수를 명시하지 않아야 한다. 대신 원래의 제네릭 정의에 명시한 타입 매개변수를 익스텐션에서 사용할 수 있다.
------------------------------------------------------------------
### chapter 22.4 타입 제약
제네릭 함수가 처리해야 할 기능이 특정 타입에 한정되어야만 처리할 수 있다던가, 제네릭 타입을 특정 프로토콜을 따르는 타입만 사용할 수 있도록 제약을 두어야 하는 상황이 발생할 수 있다. 타입 제약은 클래스 타입 or 프로토콜 타입만 줄 수 있다. 즉 열거형, 구조체 등의 타입은 타입 제약의 타입으로 사용할 수 없습니다.
------------------------------------------------------------------
### chapter 22.5 프로토콜의 연관 타입
연관 타입은 프로토콜에서 사용할 수 있는 플레이스홀더의 이름이다. 프로토콜을 정의할 때 연관 타입을 함께 정의하면 유용할 때가 많다.
