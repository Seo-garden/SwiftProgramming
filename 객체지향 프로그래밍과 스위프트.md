#객체지향 프로그래밍과 스위프트
chapter9. 구조체와 클래스
구조체를 사용하는 이유 : 작은 데이터 구조에 대해서 클래스보다 구조체가 더 빠를 수 있다. 구조체는 스택에 저장되므로 힙 할당과 관련된 오버헤드가 없다. 클래스보다 구조체는 단순한 데이터 모델링에 적합. 구조체는 값이 복사되므로 여러 스레드 간 데이터 공유 문제가 발생하지 않는다. 또한 다른 코드에서 구조체를 수정하더라도 원본 데이터엔 영향을 미치지 않는다.

구조체와 클래스의 차이 : 정리하면 값 타입(struct)의 데이터를 함수의 전달인자로 전달하면 메모리의 전달인자를 위한 인스턴스가 새로 생성. 생성된 새 인스턴스에는 전달하려는 값이 복사되어 들어감. 반면 참조 타입(class) 데이터는 전달인자로 전달할 때 기존 인스턴스의 참조를 전달하므로 새로운 인스턴스가 아닌 기존의 인스턴스 참조를 전달한다. -> 구조체는 값을 복사해서 들어가고, 클래스는 값 그대로 전달.
구조체를 사용해야 할 때.

1. 연관된 간단한 값의 집합을 캡슐화하는 것만이 목적일 때
2. 캡슐화한 값을 참조하는 것보다 복사하는 것이 합당할 때
3. 구조체에 저장된 프로퍼티가 값 타임이며 참조하는 것보다 복사하는 것이 합당할 때
4. 다른 타입으로부터 상속받거나 자신을 상속할 필요가 없을 때

chapter10. 프로퍼티와 메서드
저장 프로퍼티 : 인스턴스의 변수 or 상수 / 구조체와 클래스에만 사용
연산 프로퍼티 : 값을 저장한 것이 아니라 특정 연산을 실행한 결과값 / 클래스, 구조체, 열거형에 사용
타입 프로퍼티 : 특정 타입에 사용되는 프로퍼티 / 클래스 변수
프로퍼티 감시자 : 프로퍼티의 값이 변하는 것을 감시, 프로퍼티의 값이 변할 때 값의 변화에 따른 특정 작업을 실행.

저장 프로퍼티 -  구조체는 프로퍼티에 맞는 이니셜라이저를 자동으로 제공하지만, 클래스는 그렇지 않아서 클래스 인스턴스의 저장 프로퍼티를 사용하는 일이 좀 번거롭다. / 정리, 구조체는 프로퍼티의 초깃값을 할당했다면 굳이 전달인자로 초깃값을 넘길 필요는 없다. 하지만 기존에 초깃값을 할당할 수 있는 이니셜라이저도 사용 가능하다. 하지만 클래스는 초깃값을 지정해줬다면 사용자 정의 이니셜라이저가 되지 않는다.
지연저장 프로퍼티 - 주로 복잡한 클래스나 구조체를 구현할 때 많이 사용, 호출이 있어야 값이 저장, var 키워드로 선언, 주로 복잡한 클래스나 구조체를 구현할 때 많이 사용
이니셜라이저 : 자바에서의 오버라이드 처럼 작동하는 것으로, 구조체에서는 값을 복사해서 쓰기 위해, 클래스는 상속을 위해 사용. 
연산 프로퍼티 - 연산 프로퍼티의 접근자와 설정자를 통해 좀더 간결하고, 확실하게 표현할 수 있다. get{ return ~ ~ ~} set(){대칭자}
프로퍼티 감시자 - 프로퍼티의 값이 새로 할당될 때 마다 호출, 변경되는 값이 현재의 값과 같더라도 호출. 저장 프로퍼티 뿐만 아니라 프로퍼티를 재정의해 상속받은 저장 프로퍼티 또는 연산 프로퍼티에도 적용할 수 있다. 
willSet : 전달되는 전달인자는 프로퍼티가 변경될 값. newValue
didSet : 전달되는 전달인자는 프로퍼티가 변경되기 전의 값. oldValue

타입 프로퍼티 : 각각의 인스턴스가 아닌, 타입 자체에 속하는 프로퍼티로, 타입 자체에 영향을 미치는 프로퍼티. 인스턴스의 생성 여부와 상관없이 타입프로퍼티의 값은 하나며, 그 타입의 모든 인스턴가 공통으로 사용하는 값.
인스턴스 메서드 : 특정 타입의 인스턴스에 속한 함수를 뜻한다. 인스턴스 내부의 프로퍼티값을 변경하거나 특정 연산 결과를 반환하는 등 인스턴스와 관련된 기능을 실행함.
class 의 경우 자신의 프로퍼티 값을 수정할 때 인스턴스 메서드는 크게 신경 쓰지 않아도 되지만, 구조체나 열거형(enum) 의 경우 값 타입으로 메서드 앞에 mutating 키워드를 붙혀야 한다. -> (함수 내에 값이 변경되면 mutating 을 필수적으로 사용해야 한다.)
모든 인스턴스는 암시적으로 생성된 self 프로퍼티를 갖는다. 자바의 this 와 비슷하게 인스턴스 자기 자신을 가리키는 프로퍼티.
타입 메서드 : 타입 자체에 호출이 가능한 메서드로, static 키워드를 사용해 타입메서드임을 나타낸다. static 과 class 로 정의가 가능한데, static 으로 정의하면 상속 후 메서드 재정의가 불가능하고, class 로 정의하면 상속 후 메서드 재정의가 가능하다.
