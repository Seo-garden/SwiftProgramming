# 객체지향 프로그래밍과 스위프트
### chapter9. 구조체와 클래스
구조체를 사용하는 이유 : 작은 데이터 구조에 대해서 클래스보다 구조체가 더 빠를 수 있다. 구조체는 스택에 저장되므로 힙 할당과 관련된 오버헤드가 없다. 클래스보다 구조체는 단순한 데이터 모델링에 적합. 구조체는 값이 복사되므로 여러 스레드 간 데이터 공유 문제가 발생하지 않는다. 또한 다른 코드에서 구조체를 수정하더라도 원본 데이터엔 영향을 미치지 않는다.


구조체와 클래스의 차이 : 정리하면 값 타입(struct)의 데이터를 함수의 전달인자로 전달하면 메모리의 전달인자를 위한 인스턴스가 새로 생성. 생성된 새 인스턴스에는 전달하려는 값이 복사되어 들어감. 반면 참조 타입(class) 데이터는 전달인자로 전달할 때 기존 인스턴스의 참조를 전달하므로 새로운 인스턴스가 아닌 기존의 인스턴스 참조를 전달한다. -> 구조체는 값을 복사해서 들어가고, 클래스는 값 그대로 전달.


구조체를 사용해야 할 때.


1. 연관된 간단한 값의 집합을 캡슐화하는 것만이 목적일 때
2. 캡슐화한 값을 참조하는 것보다 복사하는 것이 합당할 때
3. 구조체에 저장된 프로퍼티가 값 타임이며 참조하는 것보다 복사하는 것이 합당할 때
4. 다른 타입으로부터 상속받거나 자신을 상속할 필요가 없을 때
--------------------------------------------------------------
### chapter10. 프로퍼티와 메서드
저장 프로퍼티 : 인스턴스의 변수 or 상수 / 구조체와 클래스에만 사용
연산 프로퍼티 : 값을 저장한 것이 아니라 특정 연산을 실행한 결과값 / 클래스, 구조체, 열거형에 사용
타입 프로퍼티 : 특정 타입에 사용되는 프로퍼티 / 클래스 변수
프로퍼티 감시자 : 프로퍼티의 값이 변하는 것을 감시, 프로퍼티의 값이 변할 때 값의 변화에 따른 특정 작업을 실행.

저장 프로퍼티 -  구조체는 프로퍼티에 맞는 이니셜라이저를 자동으로 제공하지만, 클래스는 그렇지 않아서 클래스 인스턴스의 저장 프로퍼티를 사용하는 일이 좀 번거롭다. / 정리, 구조체는 프로퍼티의 초깃값을 할당했다면 굳이 전달인자로 초깃값을 넘길 필요는 없다. 하지만 기존에 초깃값을 할당할 수 있는 이니셜라이저도 사용 가능하다. 하지만 클래스는 초깃값을 지정해줬다면 사용자 정의 이니셜라이저가 되지 않는다.


지연저장 프로퍼티 - 주로 복잡한 클래스나 구조체를 구현할 때 많이 사용, 호출이 있어야 값이 저장, var 키워드로 선언, 주로 복잡한 클래스나 구조체를 구현할 때 많이 사용


이니셜라이저 : 자바에서의 오버라이드 처럼 작동하는 것으로, 구조체에서는 값을 복사해서 쓰기 위해, 클래스는 상속을 위해 사용.
 

연산 프로퍼티 - 연산 프로퍼티의 접근자와 설정자를 통해 좀더 간결하고, 확실하게 표현할 수 있다. get{ return ~ ~ } set(){대칭자}


프로퍼티 감시자 - 프로퍼티의 값이 새로 할당될 때 마다 호출, 변경되는 값이 현재의 값과 같더라도 호출. 저장 프로퍼티 뿐만 아니라 프로퍼티를 재정의해 상속받은 저장 프로퍼티 또는 연산 프로퍼티에도 적용할 수 있다.

 
willSet : 전달되는 전달인자는 프로퍼티가 변경될 값. newValue


didSet : 전달되는 전달인자는 프로퍼티가 변경되기 전의 값. oldValue

타입 프로퍼티 : 각각의 인스턴스가 아닌, 타입 자체에 속하는 프로퍼티로, 타입 자체에 영향을 미치는 프로퍼티. 인스턴스의 생성 여부와 상관없이 타입프로퍼티의 값은 하나며, 그 타입의 모든 인스턴가 공통으로 사용하는 값.


인스턴스 메서드 : 특정 타입의 인스턴스에 속한 함수를 뜻한다. 인스턴스 내부의 프로퍼티값을 변경하거나 특정 연산 결과를 반환하는 등 인스턴스와 관련된 기능을 실행함.
class 의 경우 자신의 프로퍼티 값을 수정할 때 인스턴스 메서드는 크게 신경 쓰지 않아도 되지만, 구조체나 열거형(enum) 의 경우 값 타입으로 메서드 앞에 mutating 키워드를 붙혀야 한다. -> (함수 내에 값이 변경되면 mutating 을 필수적으로 사용해야 한다.)
모든 인스턴스는 암시적으로 생성된 self 프로퍼티를 갖는다. 자바의 this 와 비슷하게 인스턴스 자기 자신을 가리키는 프로퍼티.


타입 메서드 : 타입 자체에 호출이 가능한 메서드로, static 키워드를 사용해 타입메서드임을 나타낸다. static 과 class 로 정의가 가능한데, static 으로 정의하면 상속 후 메서드 재정의가 불가능하고, class 로 정의하면 상속 후 메서드 재정의가 가능하다. 

---------------------------------------------------------------
### chapter11. 인스턴스 생성 및 소멸
구조체와 클래스의 인스턴스는 처음 생성할 때 옵셔널 저장 프로퍼티를 제외한 모든 저장 프로퍼티에 적절한 초깃값을 할당해야 한다. 초기화 후에 값이 확정되지 않은 저장 프로퍼티는 존재할 수 없다.


초기화 과정에서 값을 초기화하지 않아도 되는, 즉 인스턴스가 사용되는 동안에 값을 꼭 갖지 않아도 되는 저장 프로퍼티가 있다면 해당 프로퍼티를 옵셔널로 선언할 수 있다. 또는 초기화 과정에서 값을 지정해주기 어려운 경우 저장 프로퍼티를 옵셔널로 선언할 수 있다. 옵셔널로 선언할 수 있음. 옵셔널로 선언 할 경우 자동으로 nil 이 할당됨.


기본 이니셜라이저와 멤버와이즈 이니셜라이저 : 기본 이니셜라이저는 클래스와 구조체 모두에서 사용 가능하며, 명시적으로 초기화 로직을 작성해야 함. 멤버와이즈 이니셜라이저는 주로 구조체에서 사용되며, 구조체의 모든 속성을 간단히 초기화할 수 있는 편리한 방법을 제공함, 클래스의 경우 멤버와이즈 이니셜라이저는 자동으로 생성되지 않음. -> 클래스의 이니셜라이저에는 파라미터가 들어갈 수 없음.


실패한 이니셜라이저 : 이니셜라이저를 통해 인스턴스를 초기화할 수 없는 여러 가지 예외 상황이 있다. 대표적으로 이니셜라이저의 전달인자로 잘못된 값이나 적절치 못한 값이 전달되었을 때, 이니셜라이저는 인스턴스 초기화에 실패한다. 실패가능한 이니셜라이저는 클래스, 구조체, 열거형 등에 모두 정의할 수 있다. 실패 가능한 이니셜라이저는 실패했을 때 nil을 반환해주므로 반환 타입이 옵셔널로 지정된다. -> init() x - init?() o
ex) 이름과 나이를 입력할 때, 이름이 없거나 나이가 0살보다 낮은 경우에 사용해야 될 것 같다.


11.2 인스턴스의 소멸 : 디이니셜라이저로 구현을 하며, 메모리에서 해제되기 직전 클래스 인스턴스와 관련하여 원하는 정리 작업을 구현. 클래스의 인스턴스가 메모리에서 소멸되기 바로 직전에 호출. 클래스의 인스턴스에서만 구현 가능. 스위프트는 인스턴스가 더 이상 필요하지 않으면 자동으로 메모리에서 소멸하기에 디이니셜라이저를 사용해서 별도의 메모리 관리 작업을 할 필요는 없지만, 인스턴스 내부에서 파일을 불러와 열어보는 등의 외부 자원을 사용했다면 인스턴스가 소멸하기 직전에 파일을 다시 저장하고 닫아주는 등의 부가 작업을 해줘야 함. 또는 인스턴스를 메모리에서 소멸하기 직전에 인스턴스에 저장되어 있던 데이터를 디스크에 파일로 저장해줘야 하는 경우 디이니셜라이저는 굉장히 유용하게 사용될 수 있다. 디이니셜라이저는 단 하나만 구현할 수 있으며, 매개변수를 갖지 않고, 소괄호도 적지 않는다. 그리고 자동으로 호출되기 때문에 별도의 코드를 호출할 수 X   
-------------------------------------------------------------------------------------------------------------
### chapter12 접근제어
객체지향 프로그래밍 패러다임에서 중요한 캡슐화와 은닉화를 구현하는 이유는 외부에서 접근하면 안 되는 코드가 있기 때문이다. 불필요한 접근으로 의도치 않은 결과를 초래하거나 꼭 필요한 부분만 제공을 해야하는데 전체 코드가 노출될 가능성이 있을 때 접근 제어를 이용함.

모듈 : 배포할 코드의 묶음 단위로 하나의 프레임워크나 라이브러리 또는 애플리케이션으로 import 키워드를 이용해 불러옴.</br>
공개 접근수준 - public</br>
어디든 쓰일 수 있다. 사용하는 스위프트의 기본 요소는 모두 공개 접근수준으로 구현되어 있다.

개방 접근수준 - open</br>
공개 접근수준 이상으로 높은 접근수준으로, 클래스와 클래스의 멤버에서만 사용이 가능하다. 공개 접근 수준과 비슷하지만 차이점이 존재한다.
- 개방 접근수준을 제외하면 다른 모든 접근수준의 클래스는 그 클래스가 정의된 모듈안에서만 상속할 수 있다.
- 개발 접근수준을 제외한 다른 모든 접근수준의 클래스 멤버는 해당 멤버가 정의된 모듈 안에서만 재정의할 수 있다.
- 개방 접근수준의 클래스는 그 클래스가 정의된 모듈 밖의 다른 모듈에서도 상속할 수 있습니다.
- 개방 접근수준의 클래스 멤버는 해당 멤버가 정의된 모듈 밖의 다른 모듈에서도 재정의할 수 있다.

내부 접근수준 - iternal</br>
기본적으로 모든 요소에 암묵적으로 지정하는 기본 접근수준으로 지정된 요소는 소스파일이 속해 있는 모듈 어디에서든 쓰일 수 있다. 다만 그 모듈을 가져다 쓰는 외부 모듈에서는 접근할 수 없다.

파일외부비공개 접근수준 - fileprivate</br>
그 요소가 구현된 소스파일 내부에서만 사용할 수 있다. 소스파일 외부에서 값이 변경되거나 함수를 호출하면 부작용이 생길 수 있는 경우에 사용하면 좋다.

비공개 접근수준 - private</br>
가장 한정적인 범위. 그 기능을 정의하고 구현한 범위 내에서만 사용할 수 있다. 
